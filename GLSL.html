<!DOCTYPE html>
<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Material+Icons" rel="stylesheet">
    <title>WIP</title>
	<style>
      html, body {
        height: 100%; 
        margin: 0px;  
      }pre{
        margin: 40px;
      }.b{
        border: 1px solid;
        padding: 15px;
      }.b:hover{
        cursor: hand;
      }#θeditor{
        height:300px;
        width:600px;
        font-size:15px;
      }#θjs{
        height:240px;
        width:600px;
        font-size:15px;
      }#θgl{
	    width: 600px;
		height: 600px;
		background-color: black;
		position: fixed;
		top: 0px;
		left: 600px;
	  }#θbuttons{
	    height: 60px;
		background-color: #303030;
		width: 600px;
	  }#θbuttons *{
	    border-radius: 1em;
		background-color: #0F0F0F;
		height: 40px;
		line-height: 40px;
		width: 40px;
		margin-top: 3px;
		margin-left: 100px;
		text-align: center;
		color: white;
		font-size: 27px;
		text-decoration: none;
	  }#θohno{
	    position:fixed;
		z-index: 5;
		top: 140px;
		left: 625px;
		background: white;
		width: 250px;
		height: 150px;
		border-radius: 25px 25px 25px 0px;
		padding: 20px;
		font-family: monospace;
		font-size: 17px;
	  }#θhelp{
	    position:fixed;
		z-index: 6;
		top: 200px;
		left: 400px;
		background: white;
		width: 400px;
		height: 200px;
		border-radius: 50px;
		padding: 20px;
		font-family: serif;
		font-size: 17px;
		text-align: center;
		visibility:hidden;
	  }
    </style> 
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.9/ace.js"></script>
	<div id="θeditor"></div>
    <div id="θbuttons">
	  <a class="material-icons">home</a>
	  <a href="javascript:θhelp(1);" class="material-icons">help</a>
	  <a href="javascript:θrunP();" class="material-icons">play_arrow</a>
	  <img id = "θeb" style="background-color: #00000000;position:relative;top:5px;" src="https://cdn.kastatic.org/third_party/javascript-khansrc/live-editor/build/images/creatures/OhNoes-Happy.png"/>
	</div>
	<div id="θjs">var oo;

</div>
    <canvas id="θgl" width="600" height="600"></canvas>
	<div id="θohno">
	  <b>Oh Noes!</b>
	  <p id="θerror">ERROR ERROR</p>
	  <a id="θwhere"><b>Show me where</b></a>
	</div>
	<div id="θhelp">
	  <b>What Is this?</b>
	  <p style="text-align: left;">
	    This is <a href="https://www.khanacademy.org/profile/KyProgramming/projects">Ky</a>'s GLSL Editor (v1). The GLSL code goes ontop, and the JavaScript goes on the bottom. To run the program, simply press the triangle play button.
	  </p>
	  <p style="text-align: left;">
	    To learn how to use this, or see a list of good GLSL tutorials and resources, please visit the <a>homepage</a>.
	  </p>
	  <a href="javascript:θhelp(0);">[Close popup]</a>
	</div>
	<!--Vertex Shader-->
    <script type="not-js" id="θvs">
attribute vec4 avtx_pos;
void main(){
  gl_Position = avtx_pos;
}
    </script>
    <!--Fragment Shader-->
    <script type="not-js" id="θfs">//Basic Raymarcher

// Credit to Iñigo Quílez for basic functions
// https://www.youtube.com/watch?v=Cfe5UQ-1L9Q
// https://www.shadertoy.com/view/3lsSzf
// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm

#ifdef GL_ES
  precision highp float;
#endif

#define MAXD 20.0
#define STYLE_AMOUNT 4

// Define u_time variable.
uniform float u_time;
// The size of the canvas
uniform vec2 u_resolution;

float rand3D(float valueX, float valueY, float valueZ){
  return fract(sin(100.0*cos(10233.5*sin(valueX)+12013.2*sin(valueY)+1111.1*cos(valueZ))));
}
float noise3D(float valueX, float valueY, float valueZ){
  float flooredValueX = floor(valueX);
  float flooredValueY = floor(valueY);
  float flooredValueZ = floor(valueZ);
  float a = rand3D(flooredValueX, flooredValueY, flooredValueZ);
  float b = rand3D(flooredValueX + 1.0, flooredValueY, flooredValueZ);
  float c = rand3D(flooredValueX, flooredValueY + 1.0, flooredValueZ);
  float d = rand3D(flooredValueX + 1.0, flooredValueY + 1.0, flooredValueZ);
  float e = rand3D(flooredValueX, flooredValueY, flooredValueZ + 1.0);
  float f = rand3D(flooredValueX + 1.0, flooredValueY, flooredValueZ + 1.0);
  float g = rand3D(flooredValueX, flooredValueY + 1.0, flooredValueZ + 1.0);
  float h = rand3D(flooredValueX + 1.0, flooredValueY + 1.0, flooredValueZ + 1.0);
  float smoothFractX = smoothstep(0.0, 1.0, fract(valueX));
  float smoothFractY = smoothstep(0.0, 1.0, fract(valueY));
  float bottom = mix(a,b,smoothFractX)+(c-a)*smoothFractY*(1.0-smoothFractX)+(d-b)*smoothFractX*smoothFractY;
  float top = mix(e,f,smoothFractX)+(g-e)*smoothFractY*(1.0-smoothFractX)+(h-f)*smoothFractX*smoothFractY;
  return mix(bottom, top, smoothstep(0.0, 1.0, fract(valueZ)));
}
float fbm3D(float valueX, float valueY, float valueZ, int detail){
  float n = 0.5 * noise3D(valueX, valueY, valueZ);
  float a = 0.25;
  int iteration = 0;
  for(int i = 0; i < 10; i++){
    if(iteration >= detail - 1){
      return n;
    }
	n += a * noise3D(valueX * 0.5 / a, valueY * 0.5 / a, valueZ * 0.5 / a);
	a /= 2.0;
    iteration ++;
  }
  return n;
}

vec2 map(vec3 pos){
  vec3 q = abs(vec3(abs(pos.x), pos.yz) + vec3(-0.9, -0.05, 0.0)) - vec3(0.1, 0.2, 0.1);
  
  float d1 = pos.y + 0.25;
  float d2 = length(pos + vec3(0.0, -0.1, 0.0)) - 0.25;
  float d3 = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.05;
  float d4 = length(vec3(pos.xy, abs(pos.z)) + vec3(0.0, 0.05, -0.9)) - 0.15;
  
  
  float mini = min(
    min(d1, d2),
	min(d3, d4)
  );
  
  float which = 0.0;
  
  if(d2 == mini){
    which = 1.0;
  }else if(d3 == mini){
    which = 2.0;
  }else if(d4 == mini){
    which = 3.0;
  }
  
  return vec2(mini, which);
}

vec3 calcNormal(vec3 pos){
  vec2 off_set = vec2(0.0001, 0.0);
  return normalize(vec3(
    map(pos + off_set.xyy).x - map(pos - off_set.xyy).x,
    map(pos + off_set.yxy).x - map(pos - off_set.yxy).x,
    map(pos + off_set.yyx).x - map(pos - off_set.yyx).x
  ));
}

vec2 castRay(vec3 origin, vec3 ray_direction, float start_dist){
  float dist = start_dist;
  vec2 mapped;
  for(int i = 0; i < 100; i ++){
    vec3 pos = origin + dist * ray_direction;
	mapped = map(pos);
    float closeness = mapped.x;
    if(closeness < 0.001){
      break;
    }
    dist += closeness;
    if(dist >= MAXD){
      break;
    }
  }
  if(dist > MAXD){
    dist = -1.0;
  }
  return vec2(dist, mapped.y);
}

vec2 castRay(vec3 origin, vec3 ray_direction){
  return castRay(origin, ray_direction, 0.0);
}

float shadow(vec3 origin, vec3 ray_direction, float spread){
  float res = 1.0;
  float dist = 0.0;
  for(int i = 0; i < 1000; i++){
    float closeness = map(origin + ray_direction*dist).x;
    if(dist >= MAXD){
      break;
    }
    if(closeness < 0.001){
      return 0.0;
    }
	res = min(res, spread*closeness/dist);
	dist += closeness;
  }
  return res;
}

void colours(inout float styles[STYLE_AMOUNT], int which, vec3 pos, float dist){
  vec3 returnC = vec3(0.0);
  float refle = 0.0;
  if(which == 0){
	int zC = int(0.5 + fract(pos.z * 2.0));
	int xC = int(0.5 + fract(pos.x * 2.0));
	float d = min(dist / 10.0, 1.0);
	returnC = vec3(mix(0.2 * (zC + xC == 1 ? 1.0 : 0.0), 0.1, d));
  }else if(which == 1){
	refle = 1.0;
	returnC = vec3(0.5);
  }else if(which == 2){
    returnC = pos.x < 0.0 ? vec3(0.2, 0.0, 0.0) : vec3(0.0, 0.0, 0.2);
  }else if(which == 3){
    returnC = pos.z < 0.0 ? vec3(0.2, 0.2, 0.0) : vec3(0.0, 0.2, 0.0);
  }
  styles[0] = returnC.r;
  styles[1] = returnC.g;
  styles[2] = returnC.b;
  styles[3] = refle;
}
vec3 sky(vec3 rayDir, vec3 sunDir){
  vec3 scol = vec3(0.3, 0.5, 1.0) - clamp(0.7 * rayDir.y, 0.0, 0.4);
  scol += vec3(1.0, 0.8, 0.5) * smoothstep(1.0, 0.0, 10.0 * length(rayDir - sunDir));
  return scol + vec3(0.7) * fbm3D(rayDir.x * 2.0, rayDir.y * 2.0, rayDir.z * 2.0, 5);
}

void main(){
  vec2 p = (2.0*gl_FragCoord.xy-u_resolution.xy) / u_resolution.y;
  
  float angle = u_time / 1.5;
  float farness = 1.5 + 0.5 * sin(u_time / 3.0);
  
  vec3 origin = vec3(farness * sin(angle), 0.5 + 0.6 * cos(u_time / 3.0), farness * cos(angle));
  
  vec3 look_dir = normalize(-origin);
  vec3 perRight = normalize(cross(look_dir, vec3(0.0, 1.0, 0.0)));
  vec3 perUp = normalize(cross(perRight, look_dir));
  vec3 ray_direction = normalize(p.x * perRight + p.y * perUp + 1.5 * look_dir);
  
  vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));
  vec3 col = vec3(0.0);
  
  
  vec2 casted = castRay(origin, ray_direction);
  float dist = casted.x;
  int which = int(casted.y);
  
  if(dist > 0.0){
    vec3 pos = origin + dist * ray_direction;
    vec3 nor = calcNormal(pos);
    
	float style[STYLE_AMOUNT];
	colours(style, which, pos, dist);
    vec3 base = vec3(style[0], style[1], style[2]);
	float refl = style[3];
	
	
	col = vec3(0.0);
	
	if(refl > 0.0){
	  vec3 refAng = reflect(ray_direction, nor);
	  casted = castRay(pos, refAng, 0.01);
	  if(casted.x > 0.0){
		vec3 rpos = pos + casted.x * refAng;
		vec3 rnor = calcNormal(rpos);
		
	    float rstyle[STYLE_AMOUNT];
	    colours(rstyle, int(casted.y), rpos, casted.x);
        vec3 rbase = vec3(rstyle[0], rstyle[1], rstyle[2]);
		  
        float rsun_sha = shadow(rpos + rnor*0.001, sun_dir, 8.0);
        
        float rsun_dif = clamp(dot(rnor, sun_dir), 0.0, 1.0);
        float rsky_dif = clamp(dot(rnor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);
        float rbou_dif = clamp(dot(rnor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);
            
		  
  	    vec3 rcol = vec3(7.0, 4.5, 3.0) * rsun_dif * rsun_sha;
        rcol += vec3(0.5, 0.8, 0.9) * (rsky_dif * 0.8 + 0.2);
        rcol += vec3(0.7, 0.3, 0.2) * rbou_dif;
        rcol *= rbase;
		rcol = pow(rcol, vec3(0.4545)) * refl;
		  
	    col += rcol;
	  }else{
	    col += sky(refAng, sun_dir) * refl;
	  }
	}
    
	if(refl < 1.0){
      float sun_sha = shadow(pos + nor*0.001, sun_dir, 8.0);
    
      float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);
      float sky_dif = clamp(dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);
      float bou_dif = clamp(dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);
      
	  col += vec3(7.0, 4.5, 3.0) * sun_dif * sun_sha * (1.0 - refl);
      col += vec3(0.5, 0.8, 0.9) * (sky_dif * 0.8 + 0.2) * (1.0 - refl);
      col += vec3(0.7, 0.3, 0.2) * bou_dif * (1.0 - refl);
	}
	
    col *= base;
  }else{
    col = sky(ray_direction, sun_dir);
  }
  
  col = pow(col, vec3(0.4545));
  
  gl_FragColor = vec4(col, 1.0);
}</script>
    <script id="θjsC" type="notjs">var time = 0;
var speed = 1;
draw = function(){
  u_vec2("u_resolution", width, height);
  u_float("u_time", time / 40);
  //u_float("u_time", frameCount / 40);
  
  time += speed;
  if(mouseIsPressed){
    speed += 0.01;
  }else{
    speed -= 0.01;
  }
  speed = Math.max(Math.min(speed, 2.5), 0.5);
};</script>
	<script src="GLSL.js"></script>
  </body>
</html>